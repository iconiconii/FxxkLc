package com.codetop.config;

import io.micrometer.core.aop.CountedAspect;
import io.micrometer.core.aop.TimedAspect;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

/**
 * Metrics configuration for the Notes functionality.
 * 
 * This configuration provides:
 * - Performance timing metrics
 * - Operation counters
 * - Business metrics for notes
 * - System health indicators
 * - Custom metric collection
 * 
 * @author CodeTop Team
 */
@Configuration
@EnableAspectJAutoProxy
public class NotesMetricsConfig {
    
    /**
     * Enable @Timed annotation support for method-level timing.
     */
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
    
    /**
     * Enable @Counted annotation support for method-level counting.
     */
    @Bean
    public CountedAspect countedAspect(MeterRegistry registry) {
        return new CountedAspect(registry);
    }
    
    /**
     * Notes creation counter.
     */
    @Bean
    public Counter notesCreatedCounter(MeterRegistry registry) {
        return Counter.builder("notes.created")
            .description("Number of notes created")
            .tag("type", "total")
            .register(registry);
    }
    
    /**
     * Notes updated counter.
     */
    @Bean
    public Counter notesUpdatedCounter(MeterRegistry registry) {
        return Counter.builder("notes.updated")
            .description("Number of notes updated")
            .tag("type", "total")
            .register(registry);
    }
    
    /**
     * Notes deleted counter.
     */
    @Bean
    public Counter notesDeletedCounter(MeterRegistry registry) {
        return Counter.builder("notes.deleted")
            .description("Number of notes deleted")
            .tag("type", "total")
            .register(registry);
    }
    
    /**
     * Notes view counter.
     */
    @Bean
    public Counter notesViewedCounter(MeterRegistry registry) {
        return Counter.builder("notes.viewed")
            .description("Number of note views")
            .tag("type", "public")
            .register(registry);
    }
    
    /**
     * Search operations counter.
     */
    @Bean
    public Counter searchOperationsCounter(MeterRegistry registry) {
        return Counter.builder("notes.search")
            .description("Number of search operations")
            .tag("type", "text")
            .register(registry);
    }
    
    /**
     * Timer for note creation operations.
     */
    @Bean
    public Timer noteCreationTimer(MeterRegistry registry) {
        return Timer.builder("notes.create.duration")
            .description("Time to create a note")
            .register(registry);
    }
    
    /**
     * Timer for note retrieval operations.
     */
    @Bean
    public Timer noteRetrievalTimer(MeterRegistry registry) {
        return Timer.builder("notes.retrieve.duration")
            .description("Time to retrieve a note")
            .register(registry);
    }
    
    /**
     * Timer for MongoDB sync operations.
     */
    @Bean
    public Timer mongoSyncTimer(MeterRegistry registry) {
        return Timer.builder("notes.mongo.sync")
            .description("MongoDB sync operation time")
            .register(registry);
    }
    
    /**
     * Timer for batch content loading operations.
     */
    @Bean
    public Timer batchLoadTimer(MeterRegistry registry) {
        return Timer.builder("notes.batch.load.duration")
            .description("Time to load content batch")
            .register(registry);
    }
    
    /**
     * Timer for search operations.
     */
    @Bean
    public Timer searchTimer(MeterRegistry registry) {
        return Timer.builder("notes.search.duration")
            .description("Time to perform search operations")
            .register(registry);
    }
    
    /**
     * Error counter for note operations.
     */
    @Bean
    public Counter notesErrorCounter(MeterRegistry registry) {
        return Counter.builder("notes.errors")
            .description("Number of errors in note operations")
            .tag("type", "general")
            .register(registry);
    }
    
    /**
     * MongoDB connection errors counter.
     */
    @Bean
    public Counter mongoErrorCounter(MeterRegistry registry) {
        return Counter.builder("notes.mongo.errors")
            .description("Number of MongoDB connection errors")
            .tag("database", "mongodb")
            .register(registry);
    }
    
    /**
     * MySQL connection errors counter.
     */
    @Bean
    public Counter mysqlErrorCounter(MeterRegistry registry) {
        return Counter.builder("notes.mysql.errors")
            .description("Number of MySQL connection errors")
            .tag("database", "mysql")
            .register(registry);
    }
    
    /**
     * Cache hit rate gauge.
     */
    @Bean
    public Gauge cacheHitRateGauge(MeterRegistry registry) {
        return Gauge.builder("notes.cache.hit.rate")
            .description("Cache hit rate for note operations")
            .register(registry, this, obj -> getCacheHitRate());
    }
    
    /**
     * Active user sessions gauge.
     */
    @Bean
    public Gauge activeSessionsGauge(MeterRegistry registry) {
        return Gauge.builder("notes.sessions.active")
            .description("Number of active user sessions")
            .register(registry, this, obj -> getActiveSessionsCount());
    }
    
    /**
     * MongoDB connection pool gauge.
     */
    @Bean
    public Gauge mongoConnectionPoolGauge(MeterRegistry registry) {
        return Gauge.builder("notes.mongo.connections.active")
            .description("Active MongoDB connections")
            .register(registry, this, obj -> getMongoConnectionCount());
    }
    
    /**
     * Content size distribution summary.
     */
    @Bean
    public io.micrometer.core.instrument.DistributionSummary contentSizeSummary(MeterRegistry registry) {
        return io.micrometer.core.instrument.DistributionSummary.builder("notes.content.size")
            .description("Distribution of note content sizes")
            .baseUnit("bytes")
            .minimumExpectedValue(100.0)
            .maximumExpectedValue(50000.0)
            .publishPercentiles(0.5, 0.75, 0.90, 0.95, 0.99)
            .register(registry);
    }
    
    /**
     * Response time distribution summary.
     */
    @Bean
    public io.micrometer.core.instrument.DistributionSummary responseTimeSummary(MeterRegistry registry) {
        return io.micrometer.core.instrument.DistributionSummary.builder("notes.response.time")
            .description("Distribution of API response times")
            .baseUnit("milliseconds")
            .minimumExpectedValue(1.0)
            .maximumExpectedValue(5000.0)
            .publishPercentiles(0.50, 0.75, 0.90, 0.95, 0.99)
            .register(registry);
    }
    
    // Helper methods for gauge values (these would be implemented to get actual values)
    
    private double getCacheHitRate() {
        // TODO: Implement actual cache hit rate calculation
        // This would typically get data from the cache manager
        return 0.85; // Placeholder
    }
    
    private double getActiveSessionsCount() {
        // TODO: Implement actual active sessions count
        // This would typically get data from session registry
        return 50.0; // Placeholder
    }
    
    private double getMongoConnectionCount() {
        // TODO: Implement actual MongoDB connection pool monitoring
        // This would typically get data from the connection pool
        return 10.0; // Placeholder
    }
}