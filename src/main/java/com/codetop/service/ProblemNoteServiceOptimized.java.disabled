package com.codetop.service;

import com.codetop.entity.ProblemNoteDocument;
import com.codetop.repository.mongo.ProblemNoteContentRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.aggregation.Aggregation;
import org.springframework.data.mongodb.core.aggregation.AggregationResults;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.stream.Collectors;

/**
 * Optimized version of ProblemNoteService performance-critical methods.
 * 
 * This service provides performance-optimized implementations for batch operations,
 * caching strategies, and async processing to improve the overall system performance.
 * 
 * Key optimizations:
 * - Batch MongoDB queries with aggregation pipelines
 * - Redis caching for frequently accessed data
 * - Async processing for non-critical operations
 * - Connection pooling optimizations
 * 
 * @author CodeTop Team
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ProblemNoteServiceOptimized {
    
    private final ProblemNoteContentRepository contentRepository;
    private final MongoTemplate mongoTemplate;
    private final Executor taskExecutor;
    
    /**
     * Optimized batch content loading using MongoDB aggregation pipeline.
     * This replaces the individual query approach in getContentBatch().
     * 
     * Performance improvements:
     * - Single aggregation query vs N individual queries
     * - Reduced network round trips
     * - Better index utilization
     * - Lower MongoDB connection usage
     * 
     * @param noteIds List of problem note IDs
     * @return Map of noteId to document content
     */
    public Map<Long, ProblemNoteDocument> getContentBatchOptimized(List<Long> noteIds) {
        if (noteIds.isEmpty()) {
            return new HashMap<>();
        }
        
        log.debug("Loading content batch for {} notes", noteIds.size());
        long startTime = System.currentTimeMillis();
        
        try {
            // Use MongoDB aggregation pipeline for efficient batch loading
            Aggregation aggregation = Aggregation.newAggregation(
                Aggregation.match(Criteria.where("problemNoteId").in(noteIds)),
                // Only project necessary fields to reduce data transfer
                Aggregation.project()
                    .and("problemNoteId").as("problemNoteId")
                    .and("content").as("content")
                    .and("solutionApproach").as("solutionApproach")
                    .and("timeComplexity").as("timeComplexity")
                    .and("spaceComplexity").as("spaceComplexity")
                    .and("tags").as("tags")
                    .and("pitfalls").as("pitfalls")
                    .and("tips").as("tips")
                    .and("lastModified").as("lastModified")
                    .and("version").as("version")
                    .and("wordCount").as("wordCount")
            );
            
            AggregationResults<ProblemNoteDocument> results = 
                mongoTemplate.aggregate(aggregation, "problem_note_contents", ProblemNoteDocument.class);
            
            // Convert to map for O(1) lookups
            Map<Long, ProblemNoteDocument> resultMap = results.getMappedResults()
                .stream()
                .collect(Collectors.toMap(
                    ProblemNoteDocument::getProblemNoteId,
                    doc -> doc,
                    (existing, replacement) -> existing // Keep first if duplicates
                ));
            
            long duration = System.currentTimeMillis() - startTime;
            log.debug("Batch loaded {} documents in {}ms", resultMap.size(), duration);
            
            return resultMap;
            
        } catch (Exception e) {
            log.error("Error in batch content loading", e);
            // Fallback to individual queries
            return getContentBatchFallback(noteIds);
        }
    }
    
    /**
     * Fallback method for batch content loading using individual queries.
     * Used when the optimized aggregation approach fails.
     */
    private Map<Long, ProblemNoteDocument> getContentBatchFallback(List<Long> noteIds) {
        log.warn("Using fallback individual query approach for {} notes", noteIds.size());
        
        Map<Long, ProblemNoteDocument> contentMap = new HashMap<>();
        for (Long noteId : noteIds) {
            try {
                contentRepository.findByProblemNoteId(noteId)
                    .ifPresent(doc -> contentMap.put(noteId, doc));
            } catch (Exception e) {
                log.warn("Failed to load content for note: {}", noteId, e);
            }
        }
        return contentMap;
    }
    
    /**
     * Cached popular notes lookup.
     * Uses Redis caching to improve performance of frequently accessed popular notes.
     * 
     * @param problemId Problem ID
     * @param limit Number of popular notes to return
     * @return List of popular note IDs
     */
    @Cacheable(value = "popularNotes", key = "#problemId + '_' + #limit", unless = "#result.isEmpty()")
    public List<Long> getPopularNoteIdsCached(Long problemId, int limit) {
        log.debug("Loading popular notes for problem: {}, limit: {}", problemId, limit);
        
        // Use MongoDB aggregation to get top notes by helpful votes and views
        Aggregation aggregation = Aggregation.newAggregation(
            // Match by problem (this would need problemId field in content collection)
            Aggregation.match(Criteria.where("problemId").is(problemId)),
            // Sort by helpfulness score (could be computed field)
            Aggregation.sort(org.springframework.data.domain.Sort.Direction.DESC, "helpfulScore"),
            // Limit results
            Aggregation.limit(limit),
            // Project only the problemNoteId
            Aggregation.project("problemNoteId")
        );
        
        try {
            AggregationResults<Map> results = mongoTemplate.aggregate(
                aggregation, "problem_note_contents", Map.class);
            
            return results.getMappedResults().stream()
                .map(result -> ((Number) result.get("problemNoteId")).longValue())
                .collect(Collectors.toList());
                
        } catch (Exception e) {
            log.error("Error loading popular notes", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Async view count increment to avoid blocking main operations.
     * This operation is performed asynchronously to improve response times.
     */
    @org.springframework.scheduling.annotation.Async("taskExecutor")
    public CompletableFuture<Void> incrementViewCountAsync(Long noteId) {
        return CompletableFuture.runAsync(() -> {
            try {
                // Use MongoDB's atomic increment operation
                Query query = new Query(Criteria.where("problemNoteId").is(noteId));
                org.springframework.data.mongodb.core.query.Update update = 
                    new org.springframework.data.mongodb.core.query.Update().inc("viewCount", 1);
                
                mongoTemplate.updateFirst(query, update, "problem_note_contents");
                
                log.debug("Incremented view count for note: {}", noteId);
            } catch (Exception e) {
                log.warn("Failed to increment view count for note: {}", noteId, e);
            }
        }, taskExecutor);
    }
    
    /**
     * Optimized full-text search using MongoDB text indexes.
     * Utilizes the text index created in the MongoDB optimization script.
     */
    public List<ProblemNoteDocument> searchNotesOptimized(String searchText, int page, int size) {
        log.debug("Searching notes with text: '{}', page: {}, size: {}", searchText, page, size);
        
        try {
            // Use MongoDB text search with proper scoring
            Query query = new Query();
            query.addCriteria(Criteria.where("$text").is(new org.springframework.data.mongodb.core.query.TextCriteria()
                .matchingAny(searchText)
                .caseSensitive(false)));
            
            // Include text search score for relevance ranking
            query.fields().include("score", new org.springframework.data.mongodb.core.query.Meta().textScore());
            
            // Sort by text search score
            query.with(org.springframework.data.domain.Sort.by(
                org.springframework.data.domain.Sort.Direction.DESC, "score"));
            
            // Apply pagination
            query.skip(page * size).limit(size);
            
            List<ProblemNoteDocument> results = mongoTemplate.find(query, ProblemNoteDocument.class, "problem_note_contents");
            
            log.debug("Found {} search results for: '{}'", results.size(), searchText);
            return results;
            
        } catch (Exception e) {
            log.error("Error in optimized note search", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Batch update operation for multiple notes.
     * Uses MongoDB bulk operations for better performance.
     */
    public void updateNotesVisibilityBatch(List<Long> noteIds, boolean isPublic) {
        if (noteIds.isEmpty()) {
            return;
        }
        
        log.info("Batch updating visibility for {} notes to: {}", noteIds.size(), isPublic);
        
        try {
            Query query = new Query(Criteria.where("problemNoteId").in(noteIds));
            org.springframework.data.mongodb.core.query.Update update = 
                new org.springframework.data.mongodb.core.query.Update()
                    .set("isPublic", isPublic)
                    .set("lastModified", new Date())
                    .inc("version", 1);
            
            org.springframework.data.mongodb.core.BulkOperations bulkOps = 
                mongoTemplate.bulkOps(org.springframework.data.mongodb.core.BulkOperations.BulkMode.UNORDERED, 
                    "problem_note_contents");
            
            bulkOps.updateMulti(query, update);
            org.springframework.data.mongodb.core.BulkOperations.BulkWriteResult result = bulkOps.execute();
            
            log.info("Bulk updated {} note documents", result.getModifiedCount());
            
        } catch (Exception e) {
            log.error("Error in batch visibility update", e);
            throw new RuntimeException("Failed to update notes visibility", e);
        }
    }
    
    /**
     * Get statistics for dashboard with caching.
     * Caches aggregate statistics to avoid expensive recalculation.
     */
    @Cacheable(value = "noteStatistics", key = "#userId", unless = "#result == null")
    public Map<String, Object> getUserStatisticsCached(Long userId) {
        log.debug("Loading cached statistics for user: {}", userId);
        
        try {
            // Use aggregation pipeline for efficient statistics calculation
            Aggregation aggregation = Aggregation.newAggregation(
                // Match user notes (this would need userId field in content collection)
                Aggregation.match(Criteria.where("userId").is(userId)),
                // Group and calculate statistics
                Aggregation.group()
                    .count().as("totalNotes")
                    .sum("viewCount").as("totalViews")
                    .sum("helpfulVotes").as("totalVotes")
                    .sum("wordCount").as("totalWords")
                    .avg("wordCount").as("avgWordCount")
            );
            
            AggregationResults<Map> results = mongoTemplate.aggregate(
                aggregation, "problem_note_contents", Map.class);
            
            List<Map> mappedResults = results.getMappedResults();
            return mappedResults.isEmpty() ? new HashMap<>() : mappedResults.get(0);
            
        } catch (Exception e) {
            log.error("Error loading user statistics", e);
            return new HashMap<>();
        }
    }
    
    /**
     * Health check for MongoDB connection and performance.
     * Returns metrics about MongoDB performance and connection status.
     */
    public Map<String, Object> getMongoHealthMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        try {
            long startTime = System.currentTimeMillis();
            
            // Test basic connectivity
            long count = mongoTemplate.count(new Query(), "problem_note_contents");
            metrics.put("totalDocuments", count);
            
            // Test query performance
            long queryTime = System.currentTimeMillis() - startTime;
            metrics.put("queryResponseTime", queryTime);
            metrics.put("connectionStatus", "healthy");
            
            // Test index usage
            Query sampleQuery = new Query(Criteria.where("problemNoteId").is(1L));
            boolean indexUsed = mongoTemplate.exists(sampleQuery, "problem_note_contents");
            metrics.put("indexesAccessible", indexUsed);
            
            log.debug("MongoDB health metrics: {}", metrics);
            
        } catch (Exception e) {
            log.error("MongoDB health check failed", e);
            metrics.put("connectionStatus", "unhealthy");
            metrics.put("error", e.getMessage());
        }
        
        return metrics;
    }
}